---
# Reusable workflow for building and pushing container images using Docker BuildKit.
name: Build and push image

on:
  workflow_call:
    inputs:
      image-name:
        description: 'Name of image (directory) to build'
        required: true
        type: string
      image-type:
        description: 'Type of image to build (base or dev)'
        required: false
        default: base
        type: string
    outputs:
      registry-paths:
        description: 'Registry paths where the image was pushed'
        value: ${{ jobs.build-and-push.outputs.registry-paths }}

jobs:
  build-and-push:
    name: Build and push ${{ inputs.image-name }} image of type ${{ inputs.image-type }}
    runs-on: ubuntu-24.04
    permissions:
      contents: read
      packages: write
    env:
      IMAGE_REGISTRY: ""
      REGISTRY_PROVIDER: ghcr.io
      REGISTRY_USER: ""
    outputs:
      registry-paths: ${{ steps.push-image.outputs.registry-paths }}

    steps:
      - name: Clone the repository
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.repository_owner }}
          password: ${{ github.token }}

      # Use Nushell for all scripts.
      - uses: hustcer/setup-nu@v3
        with:
          version: "0.101.0"

      - name: Free Disk Space (Ubuntu)
        uses: jlumbroso/free-disk-space@main
        with:
          tool-cache: false
          android: true
          dotnet: true
          haskell: true
          large-packages: true
          docker-images: true
          swap-storage: true

      # The repository owner needs to be lowercase.
      - name: Set environment variables
        shell: nu {0}
        run: |
          let owner = ($env.GITHUB_REPOSITORY_OWNER | str downcase)
          $"REGISTRY_USER=($owner)\n" | save --append $env.GITHUB_ENV
          $"IMAGE_REGISTRY=($env.REGISTRY_PROVIDER)/($owner)\n" | save --append $env.GITHUB_ENV

      - name: Build ${{ inputs.image-name }} image of type ${{ inputs.image-type }}
        id: build-image
        shell: nu {0}
        run: |
          cd ${{ inputs.image-name }}
          ./build.nu ${{ inputs.image-type }}

      - name: Push image to GitHub Container Registry
        id: push-image
        shell: nu {0}
        run: |
          let output_file = "${{ inputs.image-name }}/output.log"
          let github_output = ($env.GITHUB_OUTPUT? | default "")
          # Read from whichever output file was written
          let source = (if ($github_output != "" and ($github_output | path exists)) { $github_output } else { $output_file })
          let image = (open $source | lines | where {|l| $l starts-with "image="} | first | str replace "image=" "")
          let tags = (open $source | lines | where {|l| $l starts-with "tags="} | first | str replace "tags=" "" | split row ' ')

          mut registry_paths = []
          for tag in $tags {
            let local_tag = $"($image):($tag)"
            let remote_tag = $"($env.IMAGE_REGISTRY)/($image):($tag)"
            print $"Tagging ($local_tag) as ($remote_tag)"
            ^docker tag $local_tag $remote_tag
            print $"Pushing ($remote_tag)"
            ^docker push $remote_tag
            $registry_paths = ($registry_paths | append $remote_tag)
          }

          let paths = ($registry_paths | str join ', ')
          print $"Pushed: ($paths)"
          $"registry-paths=($paths)\n" | save --append $env.GITHUB_OUTPUT

      - name: Print image URL
        run: echo "Image pushed to ${{ steps.push-image.outputs.registry-paths }}"
